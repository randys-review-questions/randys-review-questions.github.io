<!DOCTYPE html>
<html><head><title>Randy's Review Questions</title><link rel="stylesheet" href="../../../css/style.css" type="text/css" /><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></head><h1>Randy's Review Questions</h1><h2>Data Structures Conceptual Review</h2><p>Based on content taught by Mark Sheldon in Spring 2021. Written to help study for the Final Exam.</p><hr /><p class="question">1. Which sorting algorithm is usually \(O(n \log n)\) time, but is \(O(n^2)\) in the worst case scenario?</p><ul><input type="radio" name="q1" value="1" />Heap Sort<br /><input type="radio" name="q1" value="2" />Quick Sort<br /><input type="radio" name="q1" value="3" />Selection Sort<br /><input type="radio" name="q1" value="4" />Radix Sort<br /><input type="radio" name="q1" value="5" />Merge Sort<br /><input type="radio" name="q1" value="6" />Insertion Sort<br /><input type="radio" name="q1" value="7" />Shell Sort<br /><input type="radio" name="q1" value="8" />Bucket/Counting Sort<br /><input type="radio" name="q1" value="9" />Bubble Sort<br /></ul><p id="q1correct" style="color:green;display:none;">Correct!</p><p id="q1incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: Quick Sort</p><p class="question">2. One of the worst case scenarios in the above sort occurs when the list is...</p><ul><input type="radio" name="q2" value="1" />in a random order.<br /><input type="radio" name="q2" value="2" />already sorted.<br /><input type="radio" name="q2" value="3" />bounded in range.<br /></ul><p id="q2correct" style="color:green;display:none;">Correct!</p><p id="q2incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: already sorted.</p><p class="question">3. The worst case scenario that is the answer to question 2 is the best case scenario for which other sorting method?</p><ul><input type="radio" name="q3" value="1" />Heap Sort<br /><input type="radio" name="q3" value="2" />Quick Sort<br /><input type="radio" name="q3" value="3" />Selection Sort<br /><input type="radio" name="q3" value="4" />Radix Sort<br /><input type="radio" name="q3" value="5" />Merge Sort<br /><input type="radio" name="q3" value="6" />Insertion Sort<br /><input type="radio" name="q3" value="7" />Shell Sort<br /><input type="radio" name="q3" value="8" />Bucket/Counting Sort<br /></ul><p id="q3correct" style="color:green;display:none;">Correct!</p><p id="q3incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: Insertion Sort</p><p class="question">4. Selection sort is _____; insertion sort is _____.</p><ul><input type="radio" name="q4" value="1" />stable, stable<br /><input type="radio" name="q4" value="2" />stable, unstable<br /><input type="radio" name="q4" value="3" />unstable, stable<br /><input type="radio" name="q4" value="4" />unstable, unstable<br /></ul><p id="q4correct" style="color:green;display:none;">Correct!</p><p id="q4incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: unstable, stable</p><p class="question">5. The graph traversal algorithms discussed in class have data structures that may be helpful for implementation of finding the "next" vertex to investigate. Particularly, a _____ would be helpful for BFS, a _____ would be helpful for DFS, and a _____ would be helpful for Dijkstra's Algorithm.</p><ul><input type="radio" name="q5" value="1" />stack, queue, heap<br /><input type="radio" name="q5" value="2" />stack, heap, queue<br /><input type="radio" name="q5" value="3" />queue, stack, heap<br /><input type="radio" name="q5" value="4" />queue, heap, stack<br /><input type="radio" name="q5" value="5" />heap, queue, stack<br /><input type="radio" name="q5" value="6" />heap, stack, queue<br /></ul><p id="q5correct" style="color:green;display:none;">Correct!</p><p id="q5incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: queue, stack, heap</p><p class="question">6. The best runtime one can achieve with comparison based sorts is...</p><ul><input type="radio" name="q6" value="1" />\(O(n^2)\)<br /><input type="radio" name="q6" value="2" />\(O(n \log n)\)<br /><input type="radio" name="q6" value="3" />\(O(n)\)<br /><input type="radio" name="q6" value="4" />\(O(\log n)\)<br /><input type="radio" name="q6" value="5" />\(O(1)\)<br /></ul><p id="q6correct" style="color:green;display:none;">Correct!</p><p id="q6incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: \(O(n \log n)\)</p><p class="question">7. When inserting/removing from a heap, which invariant is (re)established first?</p><ul><input type="radio" name="q7" value="1" />Shape property<br /><input type="radio" name="q7" value="2" />Heap property<br /><input type="radio" name="q7" value="3" />BST invariants<br /></ul><p id="q7correct" style="color:green;display:none;">Correct!</p><p id="q7incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: Shape property</p><p class="question">8. Let \(i\) be the index of the array representing the location of the current Node in the heap. Where is the right child?</p><ul><input type="radio" name="q8" value="1" />\(\frac{i}{2}\)<br /><input type="radio" name="q8" value="2" />\(i+1\)<br /><input type="radio" name="q8" value="3" />\(i+2\)<br /><input type="radio" name="q8" value="4" />\(2i-1\)<br /><input type="radio" name="q8" value="5" />\(2i\)<br /><input type="radio" name="q8" value="6" />\(2i+1\)<br /><input type="radio" name="q8" value="7" />\(2i+2\)<br /></ul><p id="q8correct" style="color:green;display:none;">Correct!</p><p id="q8incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: \(2i+1\)</p><p class="question">9. What is the space complexity of radix sort (including the space required to store the list to sort)?</p><ul><input type="radio" name="q9" value="1" />\(O(num\_digits)\)<br /><input type="radio" name="q9" value="2" />\(O(n+num\_digits)\)<br /><input type="radio" name="q9" value="3" />\(O(n*num\_digits)\)<br /><input type="radio" name="q9" value="4" />\(O(range\_size)\)<br /><input type="radio" name="q9" value="5" />\(O(n+range\_size)\)<br /><input type="radio" name="q9" value="6" />\(O(n*range\_size)\)<br /><input type="radio" name="q9" value="7" />\(O(base)\)<br /><input type="radio" name="q9" value="8" />\(O(n+base)\)<br /><input type="radio" name="q9" value="9" />\(O(n*base)\)<br /><input type="radio" name="q9" value="10" />\(O(n*(base+num\_digits))\)<br /><input type="radio" name="q9" value="11" />\(O(n+(base*num\_digits))\)<br /><input type="radio" name="q9" value="12" />\(O(num\_digits*(n+base))\)<br /><input type="radio" name="q9" value="13" />\(O(num\_digits+(n*base))\)<br /><input type="radio" name="q9" value="14" />\(O(metro\_sim)\)<br /></ul><p id="q9correct" style="color:green;display:none;">Correct!</p><p id="q9incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: \(O(n+base)\)</p><p class="question">10. The runtime for BFS and DFS is _____ if edges are represented in an adjacency list, and _____ if edges are represented in an adjacency matrix.</p><ul><input type="radio" name="q10" value="1" />\(O(|V|)\), \(O(|V|)\)<br /><input type="radio" name="q10" value="2" />\(O(|V|^2)\), \(O(|V|^2)\)<br /><input type="radio" name="q10" value="3" />\(O(|V|^2)\), \(O(|V|^3)\)<br /><input type="radio" name="q10" value="4" />\(O(|V|+|E|)\), \(O(|V|*|E|)\)<br /><input type="radio" name="q10" value="5" />\(O(|V|^2)\), \(O(|V|+|E|)\)<br /><input type="radio" name="q10" value="6" />\(O(|V|^2)\), \(O(|V|*|E|)\)<br /><input type="radio" name="q10" value="7" />\(O(|V|*|E|)\), \(O(|V|^2)\)<br /><input type="radio" name="q10" value="8" />\(O(|V|+|E|)\), \(O(|V|^2)\)<br /></ul><p id="q10correct" style="color:green;display:none;">Correct!</p><p id="q10incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: \(O(|V|+|E|)\), \(O(|V|^2)\)</p><p class="question">11. What is the time complexity of accessing the minimum element in a min-heap?</p><ul><input type="radio" name="q11" value="1" />\(O(1)\)<br /><input type="radio" name="q11" value="2" />\(O(n)\)<br /><input type="radio" name="q11" value="3" />\(O(\log n)\)<br /><input type="radio" name="q11" value="4" />\(O(n \log n)\)<br /><input type="radio" name="q11" value="5" />\(O(n^2)\)<br /></ul><p id="q11correct" style="color:green;display:none;">Correct!</p><p id="q11incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: \(O(1)\)</p><p class="question">12. True or False: A hash function is deterministic.</p><ul><input type="radio" name="q12" value="1" />TRUE<br /><input type="radio" name="q12" value="2" />FALSE<br /></ul><p id="q12correct" style="color:green;display:none;">Correct!</p><p id="q12incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: TRUE</p><p class="question">13. Is this an AVL tree?</p><img src="AVL tree example.PNG" alt="AVL tree example.PNG" /><ul><input type="radio" name="q13" value="1" />Yes<br /><input type="radio" name="q13" value="2" />No, the left subtree of 7 is heavier than the right subtree of 7<br /><input type="radio" name="q13" value="3" />No, the left child of 7 has a larger height than the right child of 7<br /><input type="radio" name="q13" value="4" />No, it violates an AVL tree invariant not described in the other options<br /></ul><p id="q13correct" style="color:green;display:none;">Correct!</p><p id="q13incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: No, it violates an AVL tree invariant not described in the other options</p><p class="question">14. Is the empty tree an AVL tree?</p><ul><input type="radio" name="q14" value="1" />Yes<br /><input type="radio" name="q14" value="2" />No, because it is not a BST<br /><input type="radio" name="q14" value="3" />No, because it is not balanced<br /><input type="radio" name="q14" value="4" />No, because it is empty<br /></ul><p id="q14correct" style="color:green;display:none;">Correct!</p><p id="q14incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: Yes</p><p class="question">15. You insert the following elements into a BST in this order: 5, 9, 7. What do you have to do to balance it?</p><ul><input type="radio" name="q15" value="1" />Nothing!<br /><input type="radio" name="q15" value="2" />Left rotation<br /><input type="radio" name="q15" value="3" />Right rotation<br /><input type="radio" name="q15" value="4" />Left rotation, then a right rotation<br /><input type="radio" name="q15" value="5" />Right rotation, then a left rotation<br /></ul><p id="q15correct" style="color:green;display:none;">Correct!</p><p id="q15incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: Right rotation, then a left rotation</p><p class="question">16. What is the time complexity of rebalancing an unbalanced AVL tree (tree became unbalanced after insertion or removal)?</p><ul><input type="radio" name="q16" value="1" />\(O(1)\)<br /><input type="radio" name="q16" value="2" />\(O(\log n)\)<br /><input type="radio" name="q16" value="3" />\(O(n)\)<br /><input type="radio" name="q16" value="4" />\(O(n \log n)\)<br /><input type="radio" name="q16" value="5" />\(O(n^2)\)<br /></ul><p id="q16correct" style="color:green;display:none;">Correct!</p><p id="q16incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: \(O(1)\)</p><p class="question">17. What data structure gives you constant access to each item in that structure?</p><ul><input type="radio" name="q17" value="1" />ArrayList<br /><input type="radio" name="q17" value="2" />LinkedList<br /><input type="radio" name="q17" value="3" />Binary Search Tree<br /><input type="radio" name="q17" value="4" />AVL Tree<br /></ul><p id="q17correct" style="color:green;display:none;">Correct!</p><p id="q17incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: ArrayList</p><p class="question">18. Where does Dijkstra's Algorithm fail?</p><ul><input type="radio" name="q18" value="1" />When trying to find the shortest unweighted path<br /><input type="radio" name="q18" value="2" />When trying to find the shortest weighted path<br /><input type="radio" name="q18" value="3" />When trying to find the most cost efficient path in a graph with a negative cycle<br /></ul><p id="q18correct" style="color:green;display:none;">Correct!</p><p id="q18incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: When trying to find the most cost efficient path in a graph with a negative cycle</p><p class="question">19. True or False: A binary search tree guarantees you logarithmic access to every element.</p><ul><input type="radio" name="q19" value="1" />TRUE<br /><input type="radio" name="q19" value="2" />FALSE<br /></ul><p id="q19correct" style="color:green;display:none;">Correct!</p><p id="q19incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: FALSE</p><p class="question">20. Which sorting algorithm is ideal for when all elements are within a bounded range (and the range size is small)?</p><ul><input type="radio" name="q20" value="1" />Heap Sort<br /><input type="radio" name="q20" value="2" />Quick Sort<br /><input type="radio" name="q20" value="3" />Selection Sort<br /><input type="radio" name="q20" value="4" />Radix Sort<br /><input type="radio" name="q20" value="5" />Merge Sort<br /><input type="radio" name="q20" value="6" />Insertion Sort<br /><input type="radio" name="q20" value="7" />Shell Sort<br /><input type="radio" name="q20" value="8" />Bucket/Counting Sort<br /><input type="radio" name="q20" value="9" />Bubble Sort<br /></ul><p id="q20correct" style="color:green;display:none;">Correct!</p><p id="q20incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: Bucket/Counting Sort</p><p class="question">21. The best \(O(n)\) buildHeap function...</p><ul><input type="radio" name="q21" value="1" />starts at index \(1\) and downHeaps until index \(n\).<br /><input type="radio" name="q21" value="2" />starts at index \(1\) and upHeaps until index \(n\).<br /><input type="radio" name="q21" value="3" />starts at index \(n\) and downHeaps until index \(1\).<br /><input type="radio" name="q21" value="4" />starts at index \(n\) and upHeaps until index \(1\).<br /><input type="radio" name="q21" value="5" />starts at index \(1\) and downHeaps until index \(\frac{n}{2}\).<br /><input type="radio" name="q21" value="6" />starts at index \(1\) and upHeaps until index \(\frac{n}{2}\).<br /><input type="radio" name="q21" value="7" />starts at index \(\frac{n}{2}\) and downHeaps until index \(1\).<br /><input type="radio" name="q21" value="8" />starts at index \(\frac{n}{2}\) and upHeaps until index \(1\).<br /><input type="radio" name="q21" value="9" />starts at index \(\frac{n}{2}\) and downHeaps until index \(n\).<br /><input type="radio" name="q21" value="10" />starts at index \(\frac{n}{2}\) and upHeaps until index \(n\).<br /><input type="radio" name="q21" value="11" />starts at index \(n\) and downHeaps until index \(\frac{n}{2}\).<br /><input type="radio" name="q21" value="12" />starts at index \(n\) and upHeaps until index \(\frac{n}{2}\).<br /></ul><p id="q21correct" style="color:green;display:none;">Correct!</p><p id="q21incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: starts at index \(\frac{n}{2}\) and downHeaps until index \(1\).</p><p class="question">22. It would be too much work to make a question about this, but what type of question about Dijkstra's Algorithm is very likely to show up on the exam?</p><ul><input type="radio" name="q22" value="1" />Code Dijkstra's Algorithm!<br /><input type="radio" name="q22" value="2" />Write a 5-paragraph essay about how Dijkstra's Algorithm works<br /><input type="radio" name="q22" value="3" />Fill in the same table we did in lab to find the shortest path from a start vertex<br /><input type="radio" name="q22" value="4" />Apply Dijkstra's Algorithm to find relationships between regulation of genes in a brain connectivity map.<br /></ul><p id="q22correct" style="color:green;display:none;">Correct!</p><p id="q22incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: Fill in the same table we did in lab to find the shortest path from a start vertex</p><p class="question">23. A leaf has a height of...</p><ul><input type="radio" name="q23" value="1" />-1<br /><input type="radio" name="q23" value="2" />0<br /><input type="radio" name="q23" value="3" />1<br /><input type="radio" name="q23" value="4" />2<br /><input type="radio" name="q23" value="5" />infinity<br /></ul><p id="q23correct" style="color:green;display:none;">Correct!</p><p id="q23incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: 0</p><p class="question">24. Double hashing is when you...</p><ul><input type="radio" name="q24" value="1" />store two different hash tables for the same data using different hash functions.<br /><input type="radio" name="q24" value="2" />use one function, then if there's a collision, use another hash function.<br /><input type="radio" name="q24" value="3" />concatenate one hash table with another.<br /><input type="radio" name="q24" value="4" />use linear probing until the table is full, then resort to chaining.<br /></ul><p id="q24correct" style="color:green;display:none;">Correct!</p><p id="q24incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: use one function, then if there's a collision, use another hash function.</p><p class="question">25. The hash function gets you an integer, but it's often too large to represent an array index. What do you do?</p><ul><input type="radio" name="q25" value="1" />Divide by table size<br /><input type="radio" name="q25" value="2" />Mod by table size<br /><input type="radio" name="q25" value="3" />Subtract the table size<br /><input type="radio" name="q25" value="4" />Divide by table size and then mod it by table size<br /></ul><p id="q25correct" style="color:green;display:none;">Correct!</p><p id="q25incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: Mod by table size</p><p class="question">26. Chaining CANNOT support a load factor greater than _____.</p><ul><input type="radio" name="q26" value="1" />0.7<br /><input type="radio" name="q26" value="2" />1<br /><input type="radio" name="q26" value="3" />1.5<br /><input type="radio" name="q26" value="4" />2<br /><input type="radio" name="q26" value="5" />10<br /><input type="radio" name="q26" value="6" />There is no limit.<br /></ul><p id="q26correct" style="color:green;display:none;">Correct!</p><p id="q26incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: There is no limit.</p><p class="question">27. Open addressing CANNOT support a load factor greater than _____.</p><ul><input type="radio" name="q27" value="1" />0.7<br /><input type="radio" name="q27" value="2" />1<br /><input type="radio" name="q27" value="3" />1.5<br /><input type="radio" name="q27" value="4" />2<br /><input type="radio" name="q27" value="5" />10<br /><input type="radio" name="q27" value="6" />There is no limit.<br /></ul><p id="q27correct" style="color:green;display:none;">Correct!</p><p id="q27incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: 1</p><p class="question">28. When the load factor is low, the time complexity of accessing elements in a hash table is (generally speaking)...</p><ul><input type="radio" name="q28" value="1" />\(O(1)\)<br /><input type="radio" name="q28" value="2" />\(O(\log n)\)<br /><input type="radio" name="q28" value="3" />\(O(n)\)<br /><input type="radio" name="q28" value="4" />\(O(n \log n)\)<br /><input type="radio" name="q28" value="5" />\(O(n^2)\)<br /></ul><p id="q28correct" style="color:green;display:none;">Correct!</p><p id="q28incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: \(O(1)\)</p><p class="question">29. True or False: When expanding a hash table, one can simply copy over all elements to a larger sized table.</p><ul><input type="radio" name="q29" value="1" />TRUE<br /><input type="radio" name="q29" value="2" />FALSE<br /></ul><p id="q29correct" style="color:green;display:none;">Correct!</p><p id="q29incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: FALSE</p><p class="question">30. You implement a hash table using linear probing. Each element is a struct containing the data being stored (key and value) and a boolean "filled" flag. What's missing?</p><ul><input type="radio" name="q30" value="1" />Nothing!<br /><input type="radio" name="q30" value="2" />Pointer to start of array<br /><input type="radio" name="q30" value="3" />Pointer to start of linked list<br /><input type="radio" name="q30" value="4" />Hash value<br /><input type="radio" name="q30" value="5" />Boolean "removed" flag<br /></ul><p id="q30correct" style="color:green;display:none;">Correct!</p><p id="q30incorrect" style="display:none;"><span style="color:purple;">Incorrect.</span> The correct answer was: Boolean "removed" flag</p><h3 id="score" style="color:blue;display:none;"></h3><input type="button" onclick="checkquizans()" value="Check Answers" /><br /><hr /><a href="../../../index.html">Return to Home</a><script src="../../../scripts/checkans.js"></script><script>function checkquizans() { answerKey = [["2"], ["2"], ["6"], ["3"], ["3"], ["2"], ["1"], ["6"], ["8"], ["8"], ["1"], ["1"], ["4"], ["1"], ["5"], ["1"], ["1"], ["3"], ["2"], ["8"], ["7"], ["3"], ["2"], ["2"], ["2"], ["6"], ["2"], ["1"], ["2"], ["5"]]; checkans(answerKey); }</script><noscript><p>Looks like JavaScript is disabled! The answer checker will not work without JavaScript enabled.</p></noscript></html>